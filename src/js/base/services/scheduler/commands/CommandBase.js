/// FOURJS_START_COPYRIGHT(D,2014)
/// Property of Four Js*
/// (c) Copyright Four Js 2014, 2024. All Rights Reserved.
/// * Trademark of Four Js Development Tools Europe Ltd
///   in the United States and elsewhere
///
/// This file can be modified by licensees according to the
/// product manual.
/// FOURJS_END_COPYRIGHT

"use strict";

modulum('CommandBase',
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * Commands base class.
     * @class CommandBase
     * @memberOf classes
     */
    cls.CommandBase = context.oo.Class(function() {
      return /** @lends classes.CommandBase.prototype */ {
        __name: "CommandBase",

        /** @type {boolean} */
        __virtual: true,

        /**
         * Application
         * @type {classes.VMApplication}
         */
        _app: null,

        /**
         * Command timestamp
         * @type {number}
         * */
        _time: 0, // TODO why do we need this ?

        /**
         * linked AUI node
         * @type {classes.NodeBase}
         */
        _node: null,

        /** @type {boolean} */
        _isValueNode: false,

        /** @type {boolean} */
        _executeImmediately: false,

        /** @type {?number} */
        _initialContainerOffset: null,

        /** @type {number} */
        _runAttempts: 0,

        /**
         * Command generated by the execution of this command
         * It can be a command group 
         * @type {classes.CommandBase[]} 
         * @private
         * */
        _inducedCommands: null,

        /**
         * @constructs
         * @param {classes.VMApplication} app owner
         * @param {classes.NodeBase} node linked AUI node
         */
        constructor: function(app, node) {
          this._app = app;
          this._time = Date.now();
          this._node = node;
          this._isValueNode = node?.getTag() === "Value";

          // if node is a value, keep offset value of its container
          // necessary to retrieve correct node if offset has changed between creation and execution of this command
          if (this._isValueNode) {
            const offsetContainerNode = node.getAncestorWithAttribute("offset");
            if (offsetContainerNode) {
              this._initialContainerOffset = offsetContainerNode.attribute("offset");
            }
          }
        },

        /**
         * Returns if command must be executed immediately
         * @returns {boolean} true if command must be executed immeadiately
         */
        executeImmediately() {
          return this._executeImmediately;
        },

        /**
         * Returns if command can be executed.
         * @returns {boolean} true if command can be executed
         */
        canBeExecuted: function() {
          return true;
        },

        /**
         * 
         * @returns {boolean} true if command should be retested on next run if failed
         */
        retryIfFailed: function() {
          return false;
        },

        /**
         * Check if this command needs to be sent to the VM before sending another one,
         * @returns {boolean} true if this command needs to be sent to the VM before sending another one, false otherwise
         */
        needsVmSync: function() {
          return false;
        },

        /**
         * Returns if after command executed a refresh layout is needed
         * @returns {boolean} true if refresh layout is needed
         */
        needsRefreshLayout: function() {
          return true;
        },

        /**
         * Execute command
         * @returns {boolean} the command did something ?
         */
        execute: function() {
          return false;
        },

        /**
         * Update the AUI _node because it can have changed between command creation and command execution
         * @returns {boolean} returns if the node has been correctly updated
         */
        updateNode: function() {
          // Check that offset is still the same between creation and before execution of this command
          if (this._isValueNode && this._initialContainerOffset !== null) {
            const valueListNode = this._node.getParentNode();
            const offsetContainerNode = this._node.getAncestorWithAttribute("offset");
            const containerOffset = offsetContainerNode ? offsetContainerNode.attribute("offset") : this._initialContainerOffset;

            const offsetDiff = containerOffset - this._initialContainerOffset;
            // if offset has changed need to retrieve correct value node
            if (offsetDiff !== 0) {
              const wrongIndex = this._node.getIndex("Value");
              const correctIndex = wrongIndex - offsetDiff;
              const valueNodes = valueListNode.getChildren("Value");
              if (correctIndex < valueNodes.length && correctIndex >= 0) {
                this._node = valueNodes[correctIndex];
              } else {
                // current table value nodes don't contain corresponding node anymore (offset update > page size)
                // in that case we should ignore the command
                this._node = null;
                return false;
              }
            }
          }
          return true;
        },

        /**
         * Check if a command is valid and can be executed
         * For example a command on destroyed node is invalid
         * @returns {boolean} true if the command is valid, false otherwise
         */
        checkIntegrity: function() {
          let ok = true;

          if (this._node) {
            // check that the node is not destroyed
            ok = (this._node._destroyed === false);
          }
          return ok;
        },

        /**
         * test if the request has been accepted by the VM
         * @returns {boolean} true if the request has been accepted by the VM, false otherwise
         */
        validate: function() {
          return true;
        },

        /**
         * Cancel a command not yet executed
         */
        cancel: function() {
          context.LogService.scheduler.log("[app" + this._app.applicationHash + "] " + this.__name + " command canceled",
            this);
          this._app.scheduler._removeCommand(this);
        },

        /**
         * Notify the scheduler that the command have failed
         */
        fail: function() {
          this._runAttempts += 1;
          context.LogService.scheduler.log(`[app${this._app.applicationHash}] ${this.__name} command failed.`);
          this._app.scheduler._handleFailedCommand(this);
        },

        /**
         * merges with another command
         * @param {classes.CommandBase} command the command to merge with
         * @returns {boolean} true if merged successfully
         */
        merge: function(command) {
          return false;
        },

        /**
         * Returns if only one command of this type must be added to scheduler queue
         * @return {boolean} true if command must be unique in scheduler queue
         */
        isUnique: function() {
          return false;
        },

        /**
         * get the linked AUI node
         * @returns {classes.NodeBase} the node associated to command
         */
        getNode: function() {
          return this._node;
        },

        /**
         * get the command timestamp
         * @returns {number} the command creation time
         */
        getTime: function() {
          return this._time;
        },

        /**
         * get the command run count. Usefull for commands that have the retryIfFailed() set to true
         * @returns {number} return the command runCount
         */
        getRunAttempts: function() {
          return this._runAttempts;
        },

        /**
         * @returns How many times a command can fail before cancelling it for good
         */
        getMaxRunAttempts: function() {
          return 50;
        },

        /**
         * @returns {classes.CommandBase[]} Getter for the inducedcommands list
         */
        getInducedCommands: function() {
          if (this._inducedCommands === null) {
            this._inducedCommands = [];
          }
          return this._inducedCommands;
        }
      };
    });
  }
);
